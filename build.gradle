plugins {
    id "java"
    id "edu.wpi.first.GradleRIO" version "2026.2.1"
    id "com.google.protobuf" version "0.9.3"
    id "groovy"
}

java {
    sourceCompatibility = JavaVersion.VERSION_17
    targetCompatibility = JavaVersion.VERSION_17
}

ext {
    alreadyAdded = []
}

repositories {
    mavenCentral()
    maven {
        url 'https://jitpack.io'
    }
}

def ROBOT_MAIN_CLASS = "frc.robot.Main"
def EXPECTED_NUM_OF_PIS = 0;

// Define deploy target and artifacts
deploy {
    targets {
        roborio(getTargetTypeClass('RoboRIO')) {
            team = project.frc.getTeamNumber()
            debug = project.frc.getDebugOrDefault(false)

            artifacts {
                frcJava(getArtifactTypeClass('FRCJavaArtifact')) {}

                frcStaticFileDeploy(getArtifactTypeClass('FileTreeArtifact')) {
                    files = project.fileTree("src/main/deploy")
                    directory = '/home/lvuser/deploy'
                }
            }
        }
    }
}

def deployArtifact = deploy.targets.roborio.artifacts.frcJava

wpi.java.debugJni = false

def includeDesktopSupport = false

// Define project dependencies
dependencies {
    implementation wpi.java.deps.wpilib()
    implementation wpi.java.vendor.java()

    roborioDebug wpi.java.deps.wpilibJniDebug(wpi.platforms.roborio)
    roborioDebug wpi.java.vendor.jniDebug(wpi.platforms.roborio)

    roborioRelease wpi.java.deps.wpilibJniRelease(wpi.platforms.roborio)
    roborioRelease wpi.java.vendor.jniRelease(wpi.platforms.roborio)

    nativeDebug wpi.java.deps.wpilibJniDebug(wpi.platforms.desktop)
    nativeDebug wpi.java.vendor.jniDebug(wpi.platforms.desktop)
    simulationDebug wpi.sim.enableDebug()

    nativeRelease wpi.java.deps.wpilibJniRelease(wpi.platforms.desktop)
    nativeRelease wpi.java.vendor.jniRelease(wpi.platforms.desktop)
    simulationRelease wpi.sim.enableRelease()
    
    compileOnly 'org.projectlombok:lombok:1.18.30'
    annotationProcessor 'org.projectlombok:lombok:1.18.30'
    implementation "com.google.protobuf:protobuf-java:3.22.2"

    testImplementation 'org.junit.jupiter:junit-jupiter:5.10.1'
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
}

test {
    useJUnitPlatform()
    systemProperty 'junit.jupiter.extensions.autodetection.enabled', 'true'
}

// Simulation settings
wpi.sim.addGui().defaultEnabled = true
wpi.sim.addDriverstation()

// Create a fat jar (including all dependencies) and set the manifest for WPILib
jar {
    from { configurations.runtimeClasspath.collect { it.isDirectory() ? it : zipTree(it) } }
    from sourceSets.main.allSource
    manifest edu.wpi.first.gradlerio.GradleRIOPlugin.javaManifest(ROBOT_MAIN_CLASS)
    duplicatesStrategy = DuplicatesStrategy.INCLUDE
}

// Set the jar task for deployment
deployArtifact.jarTask = jar
wpi.java.configureExecutableTasks(jar)
wpi.java.configureTestTasks(test)

// Configure the string concatenation setting for inline compilation
tasks.withType(JavaCompile) {
    options.compilerArgs.add '-XDstringConcat=inline'
}

def generateConfig() {
    def stdout = new ByteArrayOutputStream()
    def stderr = new ByteArrayOutputStream()

    try {
        project.exec {
            commandLine "npm", "run", "config", "--silent", "--", "--dir", "src/config"
            standardOutput = stdout
            errorOutput = stderr
            ignoreExitValue = false
        }

        def deployDir = new File("src/main/deploy")
        deployDir.mkdirs()
        new File(deployDir, "config").text = stdout.toString().trim()
    } catch (Exception e) {
        println "Failed to generate config: ${e.message}"
        println "Error Output:\n${stderr.toString().trim()}"
        throw e;
    }
}

// Function to build dependencies dynamically. This calls a python script that clones and builds the dependencies.
// It then adds the jars to the classpath.
def buildDynamically(configFilePath) {
    def stdout = new ByteArrayOutputStream()
    def stderr = new ByteArrayOutputStream()
    def buildFailed = false

    try {
        project.exec {
            commandLine "python3", "scripts/clone_and_build_repos.py", "--config-file-path", configFilePath
            standardOutput = stdout
            errorOutput = stderr
            ignoreExitValue = false
        }
    } catch (Exception e) {
        buildFailed = true
        // ANSI escape code for red: \u001B[31m, reset: \u001B[0m
        println "\n\n" +
                "\u001B[31m" +
                "#############################################################\n" +
                "#                                                           #\n" +
                "#                FAILED TO BUILD DEPENDENCIES!              #\n" +
                "#                                                           #\n" +
                "#############################################################\n" +
                "\u001B[0m"
        println "\u001B[31mExecution failed: ${e.message}\u001B[0m"
    }

    if (stdout.toString().contains("FAILED") || stderr.toString().toLowerCase().contains("error") || buildFailed) {
        println "\n\n" +
                "\u001B[31m" +
                "#############################################################\n" +
                "#                                                           #\n" +
                "#                FAILED TO BUILD DEPENDENCIES!              #\n" +
                "#                                                           #\n" +
                "#############################################################\n" +
                "\u001B[0m"
        println "\u001B[31mError Output:\n${stderr.toString().trim()}\u001B[0m"
        throw new Exception("Failed to build dependencies")
    }

    println "Standard Output:\n${stdout.toString().trim()}"
    println "Error Output:\n${stderr.toString().trim()}"

    // ANSI escape code for green: \u001B[32m, reset: \u001B[0m
    println "\n\n" +
        "\u001B[32m" +
        "#############################################################\n" +
        "#                                                           #\n" +
        "#                BUILT DYNAMIC DEPENDENCIES!                #\n" +
        "#                                                           #\n" +
        "#############################################################\n" +
        "\u001B[0m"

    def jarFiles = fileTree(dir: "lib/build", include: '*.jar')

    project.afterEvaluate {
        dependencies {
            implementation files(jarFiles)
        }
    }
}

def applyBackend(expectedNumOfPis) {
  def stdout = new ByteArrayOutputStream()
  def stderr = new ByteArrayOutputStream()
  def buildFailed = false

  try {
    project.exec {
      commandLine "make", "deploy-backend"
      standardOutput = stdout
      errorOutput = stderr
      ignoreExitValue = false
    }
  } catch (Exception e) {
    buildFailed = true
    println "Failed to apply backend: ${e.message}"
    println "Error Output:\n${stderr.toString().trim()}"
  }

  println stdout;
  println stderr;

  if (!stderr.toString().contains("Deployed on " + expectedNumOfPis.toString() + " Pis") && !stdout.toString().contains("Deployed on " + expectedNumOfPis.toString() + " Pis")) {
    println ""
    println "============================================================="
    println "Failed to apply backend because it was not deployed on the expected number of Pis. Please set the expected number of Pis in the build.gradle file and try again (check 'EXPECTED_NUM_OF_PIS' variable)."
    println "Expected number of Pis: " + expectedNumOfPis.toString()
    println "Deployed number of Pis: " + stdout.toString().split("Deployed on ")[1].split(" Pis")[0]
    println "============================================================="
    println ""

    throw new Exception("Failed to apply backend because it was not deployed on the expected number of Pis (expected " + expectedNumOfPis.toString() + " Pis, deployed " + stdout.toString().split("Deployed on ")[1].split(" Pis")[0] + " Pis)")
  }
}

buildDynamically("./config.ini")

tasks.register("applyBackend") {
    group = "build"
    description = "Apply backend"
    doLast {
        applyBackend(EXPECTED_NUM_OF_PIS)
    }
}

tasks.register("generateConfig") {
    group = "build"
    description = "Generate config.json from TSX output"
    doLast {
        generateConfig()
    }
}

tasks.build.dependsOn(tasks.generateConfig)
tasks.build.dependsOn(tasks.generateProto)

tasks.deploy.dependsOn(tasks.applyBackend)

tasks.jar.dependsOn(tasks.generateProto)
tasks.compileJava.dependsOn(tasks.generateProto)


protobuf {
    protoc {
        artifact = "com.google.protobuf:protoc:3.22.2"
    }
    generateProtoTasks {
        all().each { task ->
            task.builtins {
                java {
                    option 'lite'
                }
            }
        }
    }

    generatedFilesBaseDir = "$buildDir/generated/source"
}

sourceSets {
    main {
        java {
            srcDirs += "$buildDir/generated/source/proto/main/java"
        }
        proto {
            srcDirs = ['src/proto']
        }
    }
}